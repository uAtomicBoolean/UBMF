/**
 * @author Benjamin Guirlet
 * @description
 *      Handler for the command 'play'.
 */


const { SlashCommandBuilder } = require( "@discordjs/builders" );
const { CommandInteraction, Client, Guild, MessageEmbed } = require( "discord.js" );
const ytdl = require( "ytdl-core" );
const youtubedl = require( "youtube-dl-exec" ).raw;
const ytsearch = require( "yt-search" );
const {
	joinVoiceChannel,
	createAudioResource,
	createAudioPlayer
} = require( '@discordjs/voice' );
const sql = require( "../../utils/sqlManager" );



const slashCommand = new SlashCommandBuilder()
	.setName( "play" )
	.setDescription( "Joue une musique, playlist ou le résultat d'une recherche passée en paramètre" )
	.addStringOption( option =>
		option.setName( "music" )
			.setDescription( "Lien de la musique/playlist ou une recherche." )
			.setRequired( true )
	);


/**
 * The commands function. It is executed when the slash command is called.
 * @param {CommandInteraction} interaction The interaction generated by the command execution.
 * @param {Client} client The bot's client.
 */
async function execute( interaction, client ) {
	// Starting by checking is the user is in a voice channel.
	const member = await interaction.guild.members.fetch( interaction.user.id );
	const voiceChannelId = member.voice.channelId;
	if ( !voiceChannelId ) return interaction.reply( "You need to be in a voice channel to use this command!" );


	// TODO the play function.
	/*
		For that, we need to check if the bot is already in vocal, and if it is, if the user is with him.
		If not, the command fail.
		Else, we get the music information, create the ressource of the music.

		We have to manage the error in case the music is not found (search).

		If the bot is already in vocal, we add the music to the queue in the db and to the player.
			-> we send an embed indicating that we added the music to the queue with its position.
		Else, we create the VoiceConnection and AudioPlayer, add them to the client.guildsPlayer map.
			-> we send an embed indicating that the music will now be played.
	 */



	// CODE BELOW IN THIS FUNCTION IS TO BE USED FOR THE FUNCTION BODY


	/* const newGuildData = {
		connection: await connectToVoiceChannel(voiceChannelId, interaction.guild),
		player: createAudioPlayer(),
		channelId: voiceChannelId
	};
	newGuildData.connection.subscribe( newGuildData.player );

	// Starting the music bot.
	const stream = youtubedl(musicInfo.url, {
		o: '-',
		q: '',
		f: 'bestaudio[ext=webm+acodec=opus+asr=48000]/bestaudio',
		r: '100K',
	}, { stdio: ['ignore', 'pipe', 'ignore'] });

	const resource = createAudioResource( stream.stdout );

	// Adding the music to the database. */

	/*newGuildData.player.play( resource );

	newGuildData.connection.on( VoiceConnectionStatus.Disconnected, async ( oldState, newState ) => {
		try {
			await Promise.race([
				entersState(newGuildData.connection, VoiceConnectionStatus.Signalling, 5_000),
				entersState(newGuildData.connection, VoiceConnectionStatus.Connecting, 5_000),
			]);
		}
		catch( error ) {
			console.log( "Connection détruite!" );
			newGuildData.connection.destroy();
		}
	});

	newGuildData.player.on( "error", error => {
		console.error( "Une erreur est survenue avec le player!\nFichier : play.js -> player.on(error)" );
		console.log( error );
	});

	client.guildsPlayers.set( interaction.guildId, newGuildData );
	// Sending the annoucement embed.
	await interaction.reply({ embeds: [await getPlayMusicEmbed( musicInfo )] } );*/
}


/**
 * Search a video on youtube and return the first result.
 * @param {string} keywords 
 * @returns An object containing the video's data.
 */
async function videoFinder( keywords ) {
	const searchResult = await ytsearch( keywords );
	return searchResult.videos.length > 1 ? searchResult.videos[0] : null;
}


/**
 * Get the music's information in function of the source of the search (url or keywords). Then puts the information in
 * an object and returns it.
 * @param {string} param The URL or keywords search for the music.
 * @param {string} userAvatarUrl The user's avatar URL to display it in the embed.
 */
async function getMusicInfo( param, userAvatarUrl ) {
	if ( ytdl.validateURL( param ) )
		return await getSongInfoFromUrl( param, userAvatarUrl );
	else
		return await getSongInfoFromSearch( param, userAvatarUrl );
}


/**
 * Get the song information when the user gave an url.
 * @param {string} songUrl The url of the youtube video.
 * @param {string} userAvatarUrl The user's avatar URL to display it in the embed.
 * @returns {Promise<{duration: string, thumbnail: *, author: string, lengthSeconds: string, title: string, url: string}>}
 */
async function getSongInfoFromUrl( songUrl, userAvatarUrl ) {
	const songInfo = await ytdl.getBasicInfo( songUrl );
	return {
		title: songInfo.videoDetails.title,
		author: songInfo.videoDetails.author.name,
		url: songInfo.videoDetails.video_url,
		thumbnail: songInfo.videoDetails.thumbnails[songInfo.videoDetails.thumbnails.length - 1].url,
		duration: `${Math.floor( songInfo.videoDetails.lengthSeconds / 60 )}:` +
			`${songInfo.videoDetails.lengthSeconds % 60}`,
		lengthSeconds: songInfo.videoDetails.lengthSeconds,
		userAvatarUrl: userAvatarUrl
	};
}


/**
 * Get the song information when the user gave a search.
 * @param {string} searchKeywords The search entered by the user.
 * @param {string} userAvatarUrl The user's avatar URL to display it in the embed.
 * @returns {Promise<{duration, thumbnail: *, author, lengthSeconds: (number|*), title, url}|null>}
 */
async function getSongInfoFromSearch( searchKeywords, userAvatarUrl ) {
	// If the video is not an URL, then we search using yt-search.
	const song = await videoFinder( searchKeywords );
	if ( !song ) return null;

	return {
		title: song.title,
		author: song.author.name,
		url: song.url,
		thumbnail: song.thumbnail,
		duration: song.timestamp,
		lengthSeconds: song.seconds,
		userAvatarUrl: userAvatarUrl
	};
}


/**
 * Connect the bot to a voice channel.
 * Returns the connection created.
 * @param {string} voiceChannelId The ID of the channel of destination.
 * @param {Guild} guild The Guild object of the guild that contains the channel of destination.
 */
async function connectToVoiceChannel( voiceChannelId, guild ) {
	return joinVoiceChannel(
		{
			channelId: voiceChannelId,
			guildId: guild.id,
			adapterCreator: guild.voiceAdapterCreator
		}
	);
}


async function getQueueMusicEmbed( musicInfo, user ) {
	return new MessageEmbed()
		.setColor( "#00a4ff" )
		.setAuthor( "| Music added to the queue", user.avatarURL() )
		.setThumbnail( musicInfo.thumbnail )
		.setDescription(
			`[${musicInfo.title}](${musicInfo.url}) by ${musicInfo.author} [${musicInfo.duration}]`
		);
}


async function getPlayMusicEmbed( musicInfo ) {
	return new MessageEmbed()
		.setColor( "#00a4ff" )
		.setAuthor( "Now playing" )
		.setThumbnail( musicInfo.thumbnail )
		.setDescription(
			`[${musicInfo.title}](${musicInfo.url}) by ${musicInfo.author} [${musicInfo.duration}]`
		);
}


module.exports = {
	data: slashCommand,
	execute
}