/**
 * @author Benjamin Guirlet
 * @description
 *      Handler for the command 'play'.
 */


const { SlashCommandBuilder } = require( "@discordjs/builders" );
const { CommandInteraction, Client, Guild } = require( "discord.js" );
const {
	joinVoiceChannel,
	VoiceConnectionStatus,
	createAudioResource,
	createAudioPlayer,
	entersState
} = require( '@discordjs/voice' );

const ytdl = require( "ytdl-core" );
const ytsearch = require( "yt-search" );


const slashCommand = new SlashCommandBuilder()
	.setName( "play" )
	.setDescription( "Joue une musique, playlist ou le résultat d'une recherche passée en paramètre" )
	.addStringOption( option =>
		option.setName( "musique" )
			.setDescription( "Lien de la musique/playlist ou une recherche." )
			.setRequired( true )
	);


/**
 * The commands function. It is executed when the slash command is called.
 * @param {CommandInteraction} interaction The interaction generated by the command execution.
 * @param {Client} client The bot's client.
 */
async function execute( interaction, client ) {
	/*
	// Checking is the member is in a voice channel.
	const member = await interaction.guild.members.fetch( interaction.user.id );
	const voiceChannelId = member.voice.channelId;

	if ( !voiceChannelId ) return interaction.reply( "Tu dois être connecté dans un vocal!" );


	// Checking if the argument is an URL or keywords for a search.
	let musicInfo;
	const musicParam = interaction.options.getString( "musique" );
	if ( ytdl.validateURL( musicParam ) )
		musicInfo = await getSongInfoFromUrl( musicParam );
	else
		musicInfo = await getSongInfoFromSearch( musicParam );
		if ( !musicInfo ) return interaction.reply( "Aucun résultats pour cette recherche!" );

	await interaction.reply( "Getting the bot ready!" );

	// Connecting to the voice chat.
	const connection = await connectToVoiceChannel( voiceChannelId, interaction.guild );
	const player = createAudioPlayer();
	connection.subscribe(player);

	const stream = ytdl( musicInfo.url, {filter: "audioonly"} );
	const resource = createAudioResource( stream );
	player.play( resource );

	client.guildsPlayers.set(
		interaction.guildId,
		{
			voiceConnection: connection,
			player: player,
			channelId: voiceChannelId
		}
	);

	connection.on('stateChange', (oldState, newState) => {
		console.log(`Connection transitioned from ${oldState.status} to ${newState.status}`);
	});

	connection.on( "error", error => {
		console.log( "Une erreur est survenue!\nFichier play.js -> connection.on(error)");
	});

	connection.on( VoiceConnectionStatus.Disconnected, async ( oldState, newState ) => {
		try {
			await Promise.race([
				entersState(connection, VoiceConnectionStatus.Signalling, 5_000),
				entersState(connection, VoiceConnectionStatus.Connecting, 5_000),
			]);
		}
		catch( error ) {
			console.log( "Connection détruite!" );
			connection.destroy();
		}
	});


	player.on('stateChange', (oldState, newState) => {
		console.log(`Audio player transitioned from ${oldState.status} to ${newState.status}`);
	});

	player.on( "error", error => {
		console.error( "Une erreur est survenue avec le player!\nFichier : play.js -> player.on(error)" );
		console.log( error );
	}); */
}


/**
 * Search a video on youtube and return the first result.
 * @param {string} keywords 
 * @returns An object containing the video's data.
 */
async function videoFinder( keywords ) {
	const searchResult = await ytsearch( keywords );
	return searchResult.videos.length > 1 ? searchResult.videos[0] : null;
}


/**
 * Get the song information when the user gave an url.
 * @param {string} songUrl The url of the youtube video.
 * @returns {Promise<{duration: string, thumbnail: *, author: string, lengthSeconds: string, title: string, url: string}>}
 */
async function getSongInfoFromUrl( songUrl ) {
	const songInfo = await ytdl.getBasicInfo( songUrl );
	return {
		title: songInfo.videoDetails.title,
		author: songInfo.videoDetails.author.name,
		url: songInfo.videoDetails.video_url,
		thumbnail: songInfo.videoDetails.thumbnails[songInfo.videoDetails.thumbnails.length - 1].url,
		duration: `${Math.floor( songInfo.videoDetails.lengthSeconds / 60 )}:` +
			`${songInfo.videoDetails.lengthSeconds % 60}`,
		lengthSeconds: songInfo.videoDetails.lengthSeconds
	};
}


/**
 * Get the song information when the user gave a search.
 * @param {string} searchKeywords The search entered by the user.
 * @returns {Promise<{duration, thumbnail: *, author, lengthSeconds: (number|*), title, url}|null>}
 */
async function getSongInfoFromSearch( searchKeywords ) {
	// If the video is not an URL, then we search using yt-search.
	const song = await videoFinder( searchKeywords );
	if ( !song ) return null;

	return {
		title: song.title,
		author: song.author.name,
		url: song.url,
		thumbnail: song.thumbnail,
		duration: song.timestamp,
		lengthSeconds: song.seconds
	};
}


/**
 * Connect the bot to a voice channel.
 * Returns the connection created.
 * @param {string} voiceChannelId The ID of the channel of destination.
 * @param {Guild} guild The Guild object of the guild that contains the channel of destination.
 */
async function connectToVoiceChannel( voiceChannelId, guild ) {
	return joinVoiceChannel(
		{
			channelId: voiceChannelId,
			guildId: guild.id,
			adapterCreator: guild.voiceAdapterCreator
		}
	);
}


module.exports = {
	data: slashCommand,
	execute
}