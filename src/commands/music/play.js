/**
 * @author Benjamin Guirlet
 * @description
 *      Handler for the command 'play'.
 */


const { SlashCommandBuilder } = require( "@discordjs/builders" );
const { CommandInteraction, Client, Guild, MessageEmbed } = require( "discord.js" );
const {
	joinVoiceChannel,
	VoiceConnectionStatus,
	createAudioResource,
	createAudioPlayer,
	entersState
} = require( '@discordjs/voice' );

const ytdl = require( "ytdl-core" );
const ytsearch = require( "yt-search" );


const slashCommand = new SlashCommandBuilder()
	.setName( "play" )
	.setDescription( "Joue une musique, playlist ou le résultat d'une recherche passée en paramètre" )
	.addStringOption( option =>
		option.setName( "music" )
			.setDescription( "Lien de la musique/playlist ou une recherche." )
			.setRequired( true )
	);


/**
 * The commands function. It is executed when the slash command is called.
 * @param {CommandInteraction} interaction The interaction generated by the command execution.
 * @param {Client} client The bot's client.
 */
async function execute( interaction, client ) {
	// Starting by checking is the user is in a voice channel.
	const member = await interaction.guild.members.fetch( interaction.user.id );
	const voiceChannelId = member.voice.channelId;
	if ( !voiceChannelId ) return interaction.reply( "You need to be in a voice channel to use this command!" );


	// Checking if the bot is already in a voice channel in this guild.
	const guildData = client.guildsPlayers.get( interaction.guildId );
	if ( guildData ) {
		if ( voiceChannelId !== guildData.channelId )
			return interaction.reply( "You need to be in the same channel as the bot!" );

		// Loading the music's information.
		const musicInfo = await getMusicInfo( interaction.options.getString( "music" ) );
		if ( !musicInfo ) return interaction.reply( "Aucun résultats pour cette recherche!" );

		// Adding the song to the queue for the server.

		// Sending the annoucement embed.
		await interaction.reply({ embeds: [await getQueueMusicEmbed( musicInfo, interaction.user )] } );
	}
	else {

		// Creating the guild's data.
		const musicInfo = await getMusicInfo( interaction.options.getString( "music" ) );

		const newGuildData = {
			connection: await connectToVoiceChannel(voiceChannelId, interaction.guild),
			player: createAudioPlayer(),
			channelId: voiceChannelId
		};


		// Starting the music bot.
		newGuildData.connection.subscribe( newGuildData.player );
		const stream = ytdl( musicInfo.url, { filter: "audioonly" } );
		const resource = createAudioResource( stream );
		newGuildData.player.play( resource );

		newGuildData.connection.on( "error", error => {
			console.log( "Une erreur est survenue!\nFichier play.js -> connection.on(error)");
		});

		newGuildData.connection.on( VoiceConnectionStatus.Disconnected, async ( oldState, newState ) => {
			try {
				await Promise.race([
					entersState(newGuildData.connection, VoiceConnectionStatus.Signalling, 5_000),
					entersState(newGuildData.connection, VoiceConnectionStatus.Connecting, 5_000),
				]);
			}
			catch( error ) {
				console.log( "Connection détruite!" );
				newGuildData.connection.destroy();
			}
		});


		newGuildData.player.on('stateChange', (oldState, newState) => {
			console.log(`Audio player transitioned from ${oldState.status} to ${newState.status}`);
		});

		newGuildData.player.on( "error", error => {
			console.error( "Une erreur est survenue avec le player!\nFichier : play.js -> player.on(error)" );
			console.log( error );
		});

		client.guildsPlayers.set( interaction.guildId, newGuildData );
		// Sending the annoucement embed.
		await interaction.reply({ embeds: [await getPlayMusicEmbed( musicInfo )] } );
	}
}


/**
 * Search a video on youtube and return the first result.
 * @param {string} keywords 
 * @returns An object containing the video's data.
 */
async function videoFinder( keywords ) {
	const searchResult = await ytsearch( keywords );
	return searchResult.videos.length > 1 ? searchResult.videos[0] : null;
}


/**
 * Get the music's information in function of the source of the search (url or keywords). Then puts the information in
 * an object and returns it.
 * @param {string} param The URL or keywords search for the music.
 */
async function getMusicInfo( param ) {
	if ( ytdl.validateURL( param ) )
		return await getSongInfoFromUrl( param );
	else
		return await getSongInfoFromSearch( param );
}


/**
 * Get the song information when the user gave an url.
 * @param {string} songUrl The url of the youtube video.
 * @returns {Promise<{duration: string, thumbnail: *, author: string, lengthSeconds: string, title: string, url: string}>}
 */
async function getSongInfoFromUrl( songUrl ) {
	const songInfo = await ytdl.getBasicInfo( songUrl );
	return {
		title: songInfo.videoDetails.title,
		author: songInfo.videoDetails.author.name,
		url: songInfo.videoDetails.video_url,
		thumbnail: songInfo.videoDetails.thumbnails[songInfo.videoDetails.thumbnails.length - 1].url,
		duration: `${Math.floor( songInfo.videoDetails.lengthSeconds / 60 )}:` +
			`${songInfo.videoDetails.lengthSeconds % 60}`,
		lengthSeconds: songInfo.videoDetails.lengthSeconds
	};
}


/**
 * Get the song information when the user gave a search.
 * @param {string} searchKeywords The search entered by the user.
 * @returns {Promise<{duration, thumbnail: *, author, lengthSeconds: (number|*), title, url}|null>}
 */
async function getSongInfoFromSearch( searchKeywords ) {
	// If the video is not an URL, then we search using yt-search.
	const song = await videoFinder( searchKeywords );
	if ( !song ) return null;

	return {
		title: song.title,
		author: song.author.name,
		url: song.url,
		thumbnail: song.thumbnail,
		duration: song.timestamp,
		lengthSeconds: song.seconds
	};
}


/**
 * Connect the bot to a voice channel.
 * Returns the connection created.
 * @param {string} voiceChannelId The ID of the channel of destination.
 * @param {Guild} guild The Guild object of the guild that contains the channel of destination.
 */
async function connectToVoiceChannel( voiceChannelId, guild ) {
	return joinVoiceChannel(
		{
			channelId: voiceChannelId,
			guildId: guild.id,
			adapterCreator: guild.voiceAdapterCreator
		}
	);
}


async function getQueueMusicEmbed( musicInfo, user ) {
	return new MessageEmbed()
		.setColor( "#00a4ff" )
		.setAuthor( "| Music added to the queue", user.avatarURL() )
		.setThumbnail( musicInfo.thumbnail )
		.setDescription(
			`[${musicInfo.title}](${musicInfo.url}) by ${musicInfo.author} [${musicInfo.duration}]`
		);
}


async function getPlayMusicEmbed( musicInfo ) {
	return new MessageEmbed()
		.setColor( "#00a4ff" )
		.setAuthor( "Now playing" )
		.setThumbnail( musicInfo.thumbnail )
		.setDescription(
			`[${musicInfo.title}](${musicInfo.url}) by ${musicInfo.author} [${musicInfo.duration}]`
		);
}


module.exports = {
	data: slashCommand,
	execute
}